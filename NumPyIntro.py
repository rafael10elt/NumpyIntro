# -*- coding: utf-8 -*-
"""Overview of Colaboratory Features

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/notebooks/basic_features_overview.ipynb
"""

#Importando o Numpy
import numpy as np

#Criando Arrays tipo lista
vetor1 = np.array([0,1,2,3,4,5,6,7,8])
print(vetor1)

#Usando métrodos do array Numpy (soma acumulada do elementos )
vetor1.cumsum()

#A função arange cria um vetor contendo uma progressão aritmética a partir de um intervalo - start,stop,step
vetor2 = np.arange(0.,4.5,.5)
print(vetor2)

#Formato do array
np.shape(vetor2)

#Retorna 1 nas posições em diagonal e 0 no restante
z = np.eye(3)
z

#Os valores passados como parametro formam a diagonal
d = np.diag(np.array([1,2,3,4]))
d

#Array com numeros complexos
c = np.array([1+2j, 3+4j, 5+6*1j])
c

#Array com valores booleans
b = np.array({True,False,True,False})
b

#Array de Strings
s = np.array(['Python', 'R', 'Julia'])
s

#O método linspace retorna um numero de valores igualmente distribuidos no intervalo especificado
np.linspace(0,10)
#Converte para log
print(np.logspace(0,5,10))

# Criando uma matriz
matriz = np.array([[1,2,3],[4,5,6]])
print(matriz)
print(matriz.shape)

#Criando uma matriz 2x3 apenas com numeors "1"
matriz1 = np.ones((2,3))
print(matriz1)

# Criando uma matriz a partir de uma lista de listas
lista = [[13,81,22],[0,34,59],[21,48,94]]
matriz2 = np.matrix(lista)
matriz2
np.shape(matriz2)
matriz2.size
matriz2.itemsize
matriz2.nbytes

#Alterando elemento de uma matriz
matriz2[1,0]= 100



x = np.array([1,2]) #NumPy decide o tipo dos dados
y = np.array([1.0, 2.0]) #NumPy decide o tipo dos dados
z = np.array([1,2], dtype=np.float64) #Forçamos um tipo de dado em particular
print(x.dtype, y.dtype, z.dtype)

matriz3 = np.array ([[24,26],[35,89]], dtype=float)
matriz3

#Usando o método random() do NumPy
print(np.random.rand(10))

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline

print(np.random.rand(10))

plt.show((plt.hist(np.random.rand(1000))))

print(np.random.randn(5,5))

plt.show((plt.hist(np.random.rand(1000))))

imagem = np.random.rand(30,30)
plt.imshow(imagem, cmap = plt.cm.hot)
plt.colorbar()

#Operações com datasets
import os
filename = os.path.join('data.csv')

#No Windows use !more data.csv  Mac ou Linux use !head data.csv
!more data.csv

#Carregando um dataset para dentro de uma array
arquivo = np.loadtxt(filename, delimiter=',',usecols=(0,1,2,3), skiprows=1)
print(arquivo)
type(arquivo)

# Gerando um plot a partir de um arquivo usando o NumPy
var1, var2 = np.loadtxt, delimiter=',', usecols=(0,1,2,3), skiprows=1, umpack=True
plt.show(plt.plot(var1, var2, 'o',markersize=8, alpha=0.75))

#Usando NumPy em Estatísticas
#Criando um array
A = np.array([15,23,63,94,75])

#Em estatísticas a média é o valor que aponta para onde mais se concentram os dados de uma distribuição.
np.mean(A)

#Calculando o desvio padrão
np.std(A)

#Calculando a variância
np.var(A)

d = np.arange(1,10)
d
np.sum(d) #Soma

# Retorna o produto dos elementos
np.prod(d)

#Soma acumulada dos elementos
np.cumsum(d)

a = np.random.randn(400,2)
m = a.mean(0)
print(m, m.shape)

plt.plot(a[:,0], a[:,1], 'o', markersize=5, alpha=0.50)
plt.plot(m[0], m[1], 'ro', markersize=10)
plt.show

#Outras operações com Arrays
#Slicing
a = np.diag(np.arange(3))
a

a[1,1]

a[1]

b = np.arange(10)
b

# [start:end:step]
b[2:9:3]

# Comparação
a = np.array([1,2,3,4])
b = np.array([4,2,2,4])
a == b

np.array_equal(a,b)

a.min()

a.max()

# Somando um elemento ao array
np.array([1,2,3]) + 1.5

# usando o método around
a = np.array([1.2,1.5,1.6,2.5,3.5,4.5])

b = np.around(a)
b

# Criando um array
B = np.array ([1,2,3,4])
B

#Copiando um array
C = B.flatten()
C

#Criando um array
v = np.array([1,2,3])

# Adicionando uma dimensão ao array
v[:,np.newaxis], v[:,np.newaxis].shape, v[np.newaxis,:].shape

#Repetindo os elementos de um array (1,1,1,2,2,2,3,3,3)
np.repeat(v,3)

#Criando um array
w = np.array([5,6])

#Repetindo os elementos de um array(1,2,3,1,2,3,1,2,3)
np.tile(v,3)

#Concatenando
np.concatenate((v,w), axis=0)

#Copiando arrays
r = np.copy(v)
r